{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Store 5 Why We Made Store Modern software needs data representations to be fluid and always available. Users expect their UI experience to never be compromised (blocked) by new data loads. Whether an application is social, news or business-to-business, users expect a seamless experience both online and offline. International users expect minimal data downloads as many megabytes of downloaded data can quickly result in astronomical phone bills. Store is a Kotlin library for loading data from remote and local sources. Concepts Store delegate to local data sources when reading/writing/deleting items. Market is a composition of Stores. Bookkeeper tracks local changes and reports failures to sync with the network. ItemValidator reports whether a Store item is valid. An App generally has one Market following a singleton pattern for each type of Item . A Market generally has two Store(s) : one bound to a memory cache then one bound to a database. However, an App can have N Market(s) . And a Market can have N Store(s) and execute operations in any order. From 0 to offline hero Add Store dependency STORE_VERSION = \"5.0.0-alpha1\" Android implementation \"org.mobilenativefoundation.store:store5:$STORE_VERSION\" Multiplatform (Common, JVM, Native) commonMain { dependencies { implementation ( \"org.mobilenativefoundation.store:store5: $ STORE_VERSION \" ) } } Define your data types and delegates 1. Here, we create a Note Type class Note { val id : Int val title : String val content : String } 2. Next, an API to read/write Notes from a web service interface NoteApi { suspend fun getNote ( id : Int ): Result < Note , NoteException > suspend fun postNote ( note : Note ): Boolean suspend fun putNote ( id : Int , note : Note ): Boolean } class RealNoteApi ( private val client : HttpClient ) : Api { override suspend fun getNote ( id : Int ): Result < Note , NoteException > = try { client . get ( \" $ ROOT_API_URL /notes/ $ id \" ) } catch ( throwable : Throwable ) { NoteException ( throwable ) } override suspend fun postNote ( note : Note ): Boolean = try { val response = client . post ( \" $ ROOT_API_URL /notes\" ) { setBody ( note ) contentType ( ContentType . Application . Json ) } response . status == HttpStatusCode . Ok } catch ( _ : Throwable ) { false } override suspend fun putNote ( id : Int , note : Note ): Boolean = try { val response = client . post ( \" $ ROOT_API_URL /notes/ $ id \" ) { setBody ( note ) contentType ( ContentType . Application . Json ) } response . status == HttpStatusCode . Ok } catch ( _ : Throwable ) { false } } 3. Using Store 1 We provide a memory lru store for you to use but you can always make your own stores as well private val memoryLruCache = MemoryLruStore < Note > ( maxSize = 100 ) 4. Create a database Store for example delegating to SQLDelight 1 Install SQL Delight Root-Level Gradle buildscript { dependencies { classpath ( \"com.squareup.sqldelight:gradle-plugin: $ SQLDELIGHT_VERSION \" ) } } Project-Level Gradle plugins { id ( \"com.squareup.slqdelight\" ) } kotlin { sourceSets { val commonMain by getting { dependencies { implementation ( \"com.squareup.sqldelight:runtime: $ SQLDELIGHT_VERSION \" ) implementation ( \"com.squareup.sqldelight:coroutines-extensions: $ SQLDELIGHT_VERSION \" ) } } val androidMain by getting { dependencies { implementation ( \"com.squareup.sqldelight:android-driver: $ SQLDELIGHT_VERSION \" ) } } val iosMain by getting { dependencies { implementation ( \"com.squareup.sqldelight:native-driver: $ SQLDELIGHT_VERSION \" ) } } } } Create SQLDelight Database Create Note Table CREATE TABLE note ( id TEXT NOT NULL PRIMARY KEY, key TEXT UNIQUE, title TEXT, content TEXT ); get: SELECT * FROM note WHERE key = ?; getAll: SELECT * FROM note; upsert: INSERT OR REPLACE INTO note VALUES ?; delete: DELETE FROM note WHERE key = ?; deleteAll: DELETE FROM note; Create FailedWrite Table This table will be used for conflict resolution CREATE TABLE failedWrite ( key TEXT NOT NULL PRIMARY KEY, datetime INTEGER AS Long ); get: SELECT * FROM failedWrite WHERE key = ?; upsert: INSERT OR REPLACE INTO failedWrite VALUES ?; delete: DELETE FROM failedWrite WHERE key = ?; deleteAll: DELETE FROM failedWrite; Create Accessors for your Database fun Database . tryGetNote ( key : String ): Flow < Note?> = try { noteQueries . get ( key ). asFlow (). mapNotNull { it . executeAsOne . convert () } } catch ( _ : Throwable ) { flow {} } fun Database . tryWriteNote ( key : String , input : Note ): Boolean = try { noteQueries . upsert ( input . convert ( key )) true } catch ( _ : Throwable ) { false } fun Database . tryDeleteNote ( key : String ): Boolean = try { noteQueries . delete ( key ) true } catch ( _ : Throwable ) { false } fun Database . tryDeleteAllNotes ( key : String ): Boolean = try { noteQueries . deleteAll () true } catch ( _ : Throwable ) { false } Provide SQLDelight Store fun provideSqlDelightStore ( database : Database ): Store < NoteKey , NoteInput , NoteOutput > = Store . by ( reader = { key -> database . tryGetNote ( key . encode ()) }, writer = { key , input -> database . tryWriteNote ( key . encode (), input ) }, deleter = { key -> database . tryDeleteNote ( key . encode ()) }, clearer = { database . tryDeleteAllNotes () } ) 5. Provide Bookkeeper We need to give Store a way to track write failures (see here for more info https://developer.android.com/topic/architecture/data-layer/offline-first#conflict-resolution) We will use the DB table we created above fun provideBookkeeper ( database : Database ): Bookkeeper < NoteKey > = Bookkeeper . by ( read = { key -> database . tryGetFailedWrite ( key . encode ()) }, write = { key , input -> database . tryWriteFailedWrite ( key . encode (), input ) }, delete = { key -> database . tryDeleteFailedWrite ( key . encode ()) }, deleteAll = { database . tryDeleteAllFailedWrites () } ) 6. Implementing NetworkFetcher fun provideNetworkFetcher ( api : Api ): NetworkFetcher < NoteKey , NoteInput , NoteOutput > = NetworkFetcher . by ( get = { key -> api . getNote ( key . id ) }, post = { key , input -> api . putNote ( key . id !! ) }, converter = { it } ) 7. Implement NetworkUpdater fun provideNetworkUpdater ( api : Api ): NetworkUpdater < NoteKey , NoteInput , NoteOutput > = NetworkUpdater . by ( post = { key , input -> when ( key . id ) { null -> api . postNote ( input ) else -> api . putNote ( key . id , input ) } }, onCompletion = OnNetworkCompletion ( onSuccess = {}, onFailure = {} ), converter = { it } ) 8. Bringing it all together in a Market fun provideMarket ( memoryLruCacheStore : Store < NoteKey , NoteInput , NoteOutput > , sqlDelightStore : Store < NoteKey , NoteInput , NoteOutput > , bookkeeper : Bookkeeper < NoteKey > , fetcher : NetworkFetcher < NoteKey , NoteInput , NoteOutput > , updater : NetworkUpdater < NoteKey , NoteInput , NoteOutput > , ): Market < NoteKey > = Market . of ( stores = listOf ( memoryLruCacheStore , sqlDelightStore ), bookkeeper = bookkeeper , fetcher = fetcher , updater = updater ) 9. Using your Market class NoteViewModel ( private val key : NoteKey , private val coroutineScope : CoroutineScope , private val market : Market < NoteKey > ) { private val stateFlow = MutableStateFlow < NoteState > ( NoteState ( NoteViewState . Initial )) val state : StateFlow < NoteState > = stateFlow init { loadState ( refresh = true ) } fun loadState ( refresh : Boolean = false , onCompletions : List < OnMarketCompletion < NoteOutput >> = listOf () ) { val reader = ReadRequest . by ( key = key , onCompletions = onCompletions , refresh = refresh ) coroutineScope . launch { market . read ( reader ). collect { marketResponse -> val viewState = when ( marketResponse ) { Loading -> marketResponse . toLoadingViewState () is Success -> marketResponse . toSuccessViewState () is Failure -> marketResponse . toFailureViewState () Empty -> marketResponse . toEmptyViewState () } val state = NoteState ( viewState ) stateFlow . value = state } } } fun updateTitle ( nextTitle : String , onCompletions : List < OnMarketCompletion < NoteOutput >> = listOf () ) { val viewState = state . value . viewState if ( viewState is NoteViewState . Success ) { val nextNote = viewState . note . copy ( title = title ) val nextViewState = viewState . copy ( note = nextNote ) val nextState = state . value . copy ( viewState = nextViewState ) stateFlow . value = nextState val writer = WriteRequest . by ( key = key , input = nextNote , onCompletions = onCompletions ) coroutineScope . launch { val ok = market . write ( writer ) if ( ! ok ) { val nextState = state . value . copy ( error = WRITE_ERROR ) stateFlow . value = nextState } } } } } License Copyright (c) 2022 Mobile Native Foundation. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. Market can be backed by any Store \u21a9 \u21a9","title":"Store 5"},{"location":"#store-5","text":"","title":"Store 5"},{"location":"#why-we-made-store","text":"Modern software needs data representations to be fluid and always available. Users expect their UI experience to never be compromised (blocked) by new data loads. Whether an application is social, news or business-to-business, users expect a seamless experience both online and offline. International users expect minimal data downloads as many megabytes of downloaded data can quickly result in astronomical phone bills. Store is a Kotlin library for loading data from remote and local sources.","title":"Why We Made Store"},{"location":"#concepts","text":"Store delegate to local data sources when reading/writing/deleting items. Market is a composition of Stores. Bookkeeper tracks local changes and reports failures to sync with the network. ItemValidator reports whether a Store item is valid. An App generally has one Market following a singleton pattern for each type of Item . A Market generally has two Store(s) : one bound to a memory cache then one bound to a database. However, an App can have N Market(s) . And a Market can have N Store(s) and execute operations in any order.","title":"Concepts"},{"location":"#from-0-to-offline-hero","text":"","title":"From 0 to offline hero"},{"location":"#add-store-dependency","text":"STORE_VERSION = \"5.0.0-alpha1\"","title":"Add Store dependency"},{"location":"#android","text":"implementation \"org.mobilenativefoundation.store:store5:$STORE_VERSION\"","title":"Android"},{"location":"#multiplatform-common-jvm-native","text":"commonMain { dependencies { implementation ( \"org.mobilenativefoundation.store:store5: $ STORE_VERSION \" ) } }","title":"Multiplatform (Common, JVM, Native)"},{"location":"#define-your-data-types-and-delegates","text":"","title":"Define your data types and delegates"},{"location":"#1-here-we-create-a-note-type","text":"class Note { val id : Int val title : String val content : String }","title":"1. Here, we create a Note Type"},{"location":"#2-next-an-api-to-readwrite-notes-from-a-web-service","text":"interface NoteApi { suspend fun getNote ( id : Int ): Result < Note , NoteException > suspend fun postNote ( note : Note ): Boolean suspend fun putNote ( id : Int , note : Note ): Boolean } class RealNoteApi ( private val client : HttpClient ) : Api { override suspend fun getNote ( id : Int ): Result < Note , NoteException > = try { client . get ( \" $ ROOT_API_URL /notes/ $ id \" ) } catch ( throwable : Throwable ) { NoteException ( throwable ) } override suspend fun postNote ( note : Note ): Boolean = try { val response = client . post ( \" $ ROOT_API_URL /notes\" ) { setBody ( note ) contentType ( ContentType . Application . Json ) } response . status == HttpStatusCode . Ok } catch ( _ : Throwable ) { false } override suspend fun putNote ( id : Int , note : Note ): Boolean = try { val response = client . post ( \" $ ROOT_API_URL /notes/ $ id \" ) { setBody ( note ) contentType ( ContentType . Application . Json ) } response . status == HttpStatusCode . Ok } catch ( _ : Throwable ) { false } }","title":"2. Next, an API to read/write Notes from a web service"},{"location":"#3-using-store-1","text":"","title":"3. Using Store 1"},{"location":"#we-provide-a-memory-lru-store-for-you-to-use-but-you-can-always-make-your-own-stores-as-well","text":"private val memoryLruCache = MemoryLruStore < Note > ( maxSize = 100 )","title":"We provide a memory lru store for you to use but you can always make your own stores as well"},{"location":"#4-create-a-database-store-for-example-delegating-to-sqldelight-1","text":"","title":"4. Create a database Store for example delegating to SQLDelight 1"},{"location":"#install-sql-delight","text":"","title":"Install SQL Delight"},{"location":"#root-level-gradle","text":"buildscript { dependencies { classpath ( \"com.squareup.sqldelight:gradle-plugin: $ SQLDELIGHT_VERSION \" ) } }","title":"Root-Level Gradle"},{"location":"#project-level-gradle","text":"plugins { id ( \"com.squareup.slqdelight\" ) } kotlin { sourceSets { val commonMain by getting { dependencies { implementation ( \"com.squareup.sqldelight:runtime: $ SQLDELIGHT_VERSION \" ) implementation ( \"com.squareup.sqldelight:coroutines-extensions: $ SQLDELIGHT_VERSION \" ) } } val androidMain by getting { dependencies { implementation ( \"com.squareup.sqldelight:android-driver: $ SQLDELIGHT_VERSION \" ) } } val iosMain by getting { dependencies { implementation ( \"com.squareup.sqldelight:native-driver: $ SQLDELIGHT_VERSION \" ) } } } }","title":"Project-Level Gradle"},{"location":"#create-sqldelight-database","text":"","title":"Create SQLDelight Database"},{"location":"#create-note-table","text":"CREATE TABLE note ( id TEXT NOT NULL PRIMARY KEY, key TEXT UNIQUE, title TEXT, content TEXT ); get: SELECT * FROM note WHERE key = ?; getAll: SELECT * FROM note; upsert: INSERT OR REPLACE INTO note VALUES ?; delete: DELETE FROM note WHERE key = ?; deleteAll: DELETE FROM note;","title":"Create Note Table"},{"location":"#create-failedwrite-table","text":"This table will be used for conflict resolution CREATE TABLE failedWrite ( key TEXT NOT NULL PRIMARY KEY, datetime INTEGER AS Long ); get: SELECT * FROM failedWrite WHERE key = ?; upsert: INSERT OR REPLACE INTO failedWrite VALUES ?; delete: DELETE FROM failedWrite WHERE key = ?; deleteAll: DELETE FROM failedWrite;","title":"Create FailedWrite Table"},{"location":"#create-accessors-for-your-database","text":"fun Database . tryGetNote ( key : String ): Flow < Note?> = try { noteQueries . get ( key ). asFlow (). mapNotNull { it . executeAsOne . convert () } } catch ( _ : Throwable ) { flow {} } fun Database . tryWriteNote ( key : String , input : Note ): Boolean = try { noteQueries . upsert ( input . convert ( key )) true } catch ( _ : Throwable ) { false } fun Database . tryDeleteNote ( key : String ): Boolean = try { noteQueries . delete ( key ) true } catch ( _ : Throwable ) { false } fun Database . tryDeleteAllNotes ( key : String ): Boolean = try { noteQueries . deleteAll () true } catch ( _ : Throwable ) { false }","title":"Create Accessors for your Database"},{"location":"#provide-sqldelight-store","text":"fun provideSqlDelightStore ( database : Database ): Store < NoteKey , NoteInput , NoteOutput > = Store . by ( reader = { key -> database . tryGetNote ( key . encode ()) }, writer = { key , input -> database . tryWriteNote ( key . encode (), input ) }, deleter = { key -> database . tryDeleteNote ( key . encode ()) }, clearer = { database . tryDeleteAllNotes () } )","title":"Provide SQLDelight Store"},{"location":"#5-provide-bookkeeper","text":"We need to give Store a way to track write failures (see here for more info https://developer.android.com/topic/architecture/data-layer/offline-first#conflict-resolution) We will use the DB table we created above fun provideBookkeeper ( database : Database ): Bookkeeper < NoteKey > = Bookkeeper . by ( read = { key -> database . tryGetFailedWrite ( key . encode ()) }, write = { key , input -> database . tryWriteFailedWrite ( key . encode (), input ) }, delete = { key -> database . tryDeleteFailedWrite ( key . encode ()) }, deleteAll = { database . tryDeleteAllFailedWrites () } )","title":"5. Provide Bookkeeper"},{"location":"#6-implementing-networkfetcher","text":"fun provideNetworkFetcher ( api : Api ): NetworkFetcher < NoteKey , NoteInput , NoteOutput > = NetworkFetcher . by ( get = { key -> api . getNote ( key . id ) }, post = { key , input -> api . putNote ( key . id !! ) }, converter = { it } )","title":"6. Implementing NetworkFetcher"},{"location":"#7-implement-networkupdater","text":"fun provideNetworkUpdater ( api : Api ): NetworkUpdater < NoteKey , NoteInput , NoteOutput > = NetworkUpdater . by ( post = { key , input -> when ( key . id ) { null -> api . postNote ( input ) else -> api . putNote ( key . id , input ) } }, onCompletion = OnNetworkCompletion ( onSuccess = {}, onFailure = {} ), converter = { it } )","title":"7. Implement NetworkUpdater"},{"location":"#8-bringing-it-all-together-in-a-market","text":"fun provideMarket ( memoryLruCacheStore : Store < NoteKey , NoteInput , NoteOutput > , sqlDelightStore : Store < NoteKey , NoteInput , NoteOutput > , bookkeeper : Bookkeeper < NoteKey > , fetcher : NetworkFetcher < NoteKey , NoteInput , NoteOutput > , updater : NetworkUpdater < NoteKey , NoteInput , NoteOutput > , ): Market < NoteKey > = Market . of ( stores = listOf ( memoryLruCacheStore , sqlDelightStore ), bookkeeper = bookkeeper , fetcher = fetcher , updater = updater )","title":"8. Bringing it all together in a Market"},{"location":"#9-using-your-market","text":"class NoteViewModel ( private val key : NoteKey , private val coroutineScope : CoroutineScope , private val market : Market < NoteKey > ) { private val stateFlow = MutableStateFlow < NoteState > ( NoteState ( NoteViewState . Initial )) val state : StateFlow < NoteState > = stateFlow init { loadState ( refresh = true ) } fun loadState ( refresh : Boolean = false , onCompletions : List < OnMarketCompletion < NoteOutput >> = listOf () ) { val reader = ReadRequest . by ( key = key , onCompletions = onCompletions , refresh = refresh ) coroutineScope . launch { market . read ( reader ). collect { marketResponse -> val viewState = when ( marketResponse ) { Loading -> marketResponse . toLoadingViewState () is Success -> marketResponse . toSuccessViewState () is Failure -> marketResponse . toFailureViewState () Empty -> marketResponse . toEmptyViewState () } val state = NoteState ( viewState ) stateFlow . value = state } } } fun updateTitle ( nextTitle : String , onCompletions : List < OnMarketCompletion < NoteOutput >> = listOf () ) { val viewState = state . value . viewState if ( viewState is NoteViewState . Success ) { val nextNote = viewState . note . copy ( title = title ) val nextViewState = viewState . copy ( note = nextNote ) val nextState = state . value . copy ( viewState = nextViewState ) stateFlow . value = nextState val writer = WriteRequest . by ( key = key , input = nextNote , onCompletions = onCompletions ) coroutineScope . launch { val ok = market . write ( writer ) if ( ! ok ) { val nextState = state . value . copy ( error = WRITE_ERROR ) stateFlow . value = nextState } } } } }","title":"9. Using your Market"},{"location":"#license","text":"Copyright (c) 2022 Mobile Native Foundation. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. Market can be backed by any Store \u21a9 \u21a9","title":"License"}]}