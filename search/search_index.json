{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Store5 Why We Made Store Modern software needs data representations to be fluid and always available Users expect their UI experience to never be compromised (blocked) by new data loads. Whether an application is social, news or business-to-business, users expect a seamless experience both online and offline International users expect minimal data downloads as many megabytes of downloaded data can quickly result in astronomical phone bills Concepts Store is responsible for managing a particular read request MutableStore is a Store that also manages particular write requests and coordinates synchronization and conflict resolution SourceOfTruth persists Item(s) Fetcher defines how data will be fetched over network Updater defines how local changes will be pushed to network Bookkeeper tracks metadata of local changes and records synchronization failures Validator returns whether an Item is valid Converter converts Item(s) between Network / Common / SOT representations How To Include In Your Project Android implementation \"org.mobilenativefoundation.store:store5:5.0.0-alpha03\" Multiplatform (Common, JVM, Native, JS) commonMain { dependencies { implementation ( \"org.mobilenativefoundation.store:store5:5.0.0-alpha03\" ) } } See Also Google Offline-First Guidance https://github.com/google/guava/wiki/CachesExplained License Copyright (c) 2022 Mobile Native Foundation. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.","title":"Store5"},{"location":"#store5","text":"","title":"Store5"},{"location":"#why-we-made-store","text":"Modern software needs data representations to be fluid and always available Users expect their UI experience to never be compromised (blocked) by new data loads. Whether an application is social, news or business-to-business, users expect a seamless experience both online and offline International users expect minimal data downloads as many megabytes of downloaded data can quickly result in astronomical phone bills","title":"Why We Made Store"},{"location":"#concepts","text":"Store is responsible for managing a particular read request MutableStore is a Store that also manages particular write requests and coordinates synchronization and conflict resolution SourceOfTruth persists Item(s) Fetcher defines how data will be fetched over network Updater defines how local changes will be pushed to network Bookkeeper tracks metadata of local changes and records synchronization failures Validator returns whether an Item is valid Converter converts Item(s) between Network / Common / SOT representations","title":"Concepts"},{"location":"#how-to-include-in-your-project","text":"","title":"How To Include In Your Project"},{"location":"#android","text":"implementation \"org.mobilenativefoundation.store:store5:5.0.0-alpha03\"","title":"Android"},{"location":"#multiplatform-common-jvm-native-js","text":"commonMain { dependencies { implementation ( \"org.mobilenativefoundation.store:store5:5.0.0-alpha03\" ) } }","title":"Multiplatform (Common, JVM, Native, JS)"},{"location":"#see-also","text":"Google Offline-First Guidance https://github.com/google/guava/wiki/CachesExplained","title":"See Also"},{"location":"#license","text":"Copyright (c) 2022 Mobile Native Foundation. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License.","title":"License"},{"location":"mutable-store/building/builder/","text":"Bringing It All Together There are two ways to build a MutableStore : A. Using a StoreBuilder interface StoreBuilder < Key : Any , Network : Any , Common : Any , SOT : Any > { companion object { fun from < Key : Any , Network : Any , Common : Any , SOT : Any > ( fetcher : Fetcher < Key , Network > , sourceOfTruth : SourceOfTruth < Key , SOT > ): StoreBuilder < Key , Network , Common , SOT > } } interface StoreBuilder < Key : Any , Network : Any , Common : Any , SOT : Any > { fun < UpdaterResult : Any > build ( updater : Updater < Key , Common , UpdaterResult > , bookkeeper : Bookkeeper < Key > ): MutableStore < Key , Common > } Example fun provide ( fetcher : Fetcher < NotesKey , NetworkNote > , sourceOfTruth : SourceOfTruth < NotesKey , Note > , updater : Updater < NotesKey , CommonNote , NotesUpdaterResult > , bookkeeper : Bookkeeper < NotesKey > , converter : Converter < NetworkNote , CommonNote , Note > , validator : Validator < CommonNote > ): MutableStore < NotesKey , CommonNote > = StoreBuilder . from < NotesKey , NetworkNote , CommonNote , Note > ( fetcher = fetcher , sourceOfTruth = sourceOfTruth ) . converter ( converter ) . validator ( validator ) . build < NotesUpdaterResult > ( updater = updater , bookkeeper = bookkeeper ) B. Transforming a Store fun < Key : Any , Network : Any , Common : Any , SOT : Any , UpdaterResult : Any > Store < Key , Common > . asMutableStore ( updater : Updater < Key , Common , UpdaterResult > , bookkeeper : Bookkeeper < Key > ): MutableStore < Key , Common > Example fun provide ( store : Store < NotesKey , CommonNote > , updater : Updater < NotesKey , CommonNote , NotesUpdaterResult > bookkeeper : Bookkeeper < NotesKey > ): MutableStore < NotesKey , CommonNote > = store . asMutableStore ( updater = updater , bookkeeper = bookkeeper )","title":"Bringing It All Together"},{"location":"mutable-store/building/builder/#bringing-it-all-together","text":"","title":"Bringing It All Together"},{"location":"mutable-store/building/builder/#there-are-two-ways-to-build-a-mutablestore","text":"","title":"There are two ways to build a MutableStore:"},{"location":"mutable-store/building/builder/#a-using-a-storebuilder","text":"interface StoreBuilder < Key : Any , Network : Any , Common : Any , SOT : Any > { companion object { fun from < Key : Any , Network : Any , Common : Any , SOT : Any > ( fetcher : Fetcher < Key , Network > , sourceOfTruth : SourceOfTruth < Key , SOT > ): StoreBuilder < Key , Network , Common , SOT > } } interface StoreBuilder < Key : Any , Network : Any , Common : Any , SOT : Any > { fun < UpdaterResult : Any > build ( updater : Updater < Key , Common , UpdaterResult > , bookkeeper : Bookkeeper < Key > ): MutableStore < Key , Common > }","title":"A. Using a StoreBuilder"},{"location":"mutable-store/building/builder/#example","text":"fun provide ( fetcher : Fetcher < NotesKey , NetworkNote > , sourceOfTruth : SourceOfTruth < NotesKey , Note > , updater : Updater < NotesKey , CommonNote , NotesUpdaterResult > , bookkeeper : Bookkeeper < NotesKey > , converter : Converter < NetworkNote , CommonNote , Note > , validator : Validator < CommonNote > ): MutableStore < NotesKey , CommonNote > = StoreBuilder . from < NotesKey , NetworkNote , CommonNote , Note > ( fetcher = fetcher , sourceOfTruth = sourceOfTruth ) . converter ( converter ) . validator ( validator ) . build < NotesUpdaterResult > ( updater = updater , bookkeeper = bookkeeper )","title":"Example"},{"location":"mutable-store/building/builder/#b-transforming-a-store","text":"fun < Key : Any , Network : Any , Common : Any , SOT : Any , UpdaterResult : Any > Store < Key , Common > . asMutableStore ( updater : Updater < Key , Common , UpdaterResult > , bookkeeper : Bookkeeper < Key > ): MutableStore < Key , Common >","title":"B. Transforming a Store"},{"location":"mutable-store/building/builder/#example_1","text":"fun provide ( store : Store < NotesKey , CommonNote > , updater : Updater < NotesKey , CommonNote , NotesUpdaterResult > bookkeeper : Bookkeeper < NotesKey > ): MutableStore < NotesKey , CommonNote > = store . asMutableStore ( updater = updater , bookkeeper = bookkeeper )","title":"Example"},{"location":"mutable-store/building/overview/","text":"Overview 1. Define generics Key - unique identifier for Item Network - representation of Item on network Common - representation of Item into/out of Store SOT - representation of Item in SourceofTruth UpdaterResult - result from network update 2. Provide implementations Fetcher SourceOfTruth Updater Bookkeeper Validator Converter","title":"Overview"},{"location":"mutable-store/building/overview/#overview","text":"","title":"Overview"},{"location":"mutable-store/building/overview/#1-define-generics","text":"Key - unique identifier for Item Network - representation of Item on network Common - representation of Item into/out of Store SOT - representation of Item in SourceofTruth UpdaterResult - result from network update","title":"1. Define generics"},{"location":"mutable-store/building/overview/#2-provide-implementations","text":"Fetcher SourceOfTruth Updater Bookkeeper Validator Converter","title":"2. Provide implementations"},{"location":"mutable-store/building/generics/common/","text":"Common Common : Any Example data class CommonNote ( val noteId : Int , val authorId : Int , val title : String , val content : String val ttl : Long? , )","title":"Common"},{"location":"mutable-store/building/generics/common/#common","text":"Common : Any","title":"Common"},{"location":"mutable-store/building/generics/common/#example","text":"data class CommonNote ( val noteId : Int , val authorId : Int , val title : String , val content : String val ttl : Long? , )","title":"Example"},{"location":"mutable-store/building/generics/key/","text":"Key Key : Any Examples Int data class NotesKey ( val noteId : Int ) sealed class NotesKey { sealed class Read : NotesKey () { data class ByNoteId ( val noteId : Int ) : Read () data class ByAuthorId ( val authorId : Int ) : Read () data class Paginated ( val start : Int , val size : Int ) : Read () } sealed class Write : NotesKey () { object Create : Write () data class ById ( val noteId : Int ) : Write () } sealed class Clear : NotesKey () { object All : Clear () data class ById ( val noteId : Int ) : Clear () } }","title":"Key"},{"location":"mutable-store/building/generics/key/#key","text":"Key : Any","title":"Key"},{"location":"mutable-store/building/generics/key/#examples","text":"Int data class NotesKey ( val noteId : Int ) sealed class NotesKey { sealed class Read : NotesKey () { data class ByNoteId ( val noteId : Int ) : Read () data class ByAuthorId ( val authorId : Int ) : Read () data class Paginated ( val start : Int , val size : Int ) : Read () } sealed class Write : NotesKey () { object Create : Write () data class ById ( val noteId : Int ) : Write () } sealed class Clear : NotesKey () { object All : Clear () data class ById ( val noteId : Int ) : Clear () } }","title":"Examples"},{"location":"mutable-store/building/generics/network/","text":"Network Network : Any Example data class NetworkNote ( val _id : Int , val authorId : Int , val title : String , val content : String )","title":"Network"},{"location":"mutable-store/building/generics/network/#network","text":"Network : Any","title":"Network"},{"location":"mutable-store/building/generics/network/#example","text":"data class NetworkNote ( val _id : Int , val authorId : Int , val title : String , val content : String )","title":"Example"},{"location":"mutable-store/building/generics/sot/","text":"SOT SOT : Any Example data class Note ( val id : Int , val authorId : Int , val title : String , val content : String , val ttl : Long )","title":"SOT"},{"location":"mutable-store/building/generics/sot/#sot","text":"SOT : Any","title":"SOT"},{"location":"mutable-store/building/generics/sot/#example","text":"data class Note ( val id : Int , val authorId : Int , val title : String , val content : String , val ttl : Long )","title":"Example"},{"location":"mutable-store/building/generics/updater-result/","text":"UpdaterResult UpdaterResult : Any Example sealed class NotesUpdaterResult { abstract val status : Int sealed class Success : NotesNetworkWriteResponse () { data class Ok ( override val status : Int ) : Success () data class Created ( override val status : Int ) : Success () } sealed class Failure : NotesNetworkWriteResponse () { data class ClientError ( override val status : Int ) : Failure () data class ServerError ( override val status : Int ) : Failure () } }","title":"UpdaterResult"},{"location":"mutable-store/building/generics/updater-result/#updaterresult","text":"UpdaterResult : Any","title":"UpdaterResult"},{"location":"mutable-store/building/generics/updater-result/#example","text":"sealed class NotesUpdaterResult { abstract val status : Int sealed class Success : NotesNetworkWriteResponse () { data class Ok ( override val status : Int ) : Success () data class Created ( override val status : Int ) : Success () } sealed class Failure : NotesNetworkWriteResponse () { data class ClientError ( override val status : Int ) : Failure () data class ServerError ( override val status : Int ) : Failure () } }","title":"Example"},{"location":"mutable-store/building/implementations/bookkeeper/","text":"Bookkeeper interface Bookkeeper < Key : Any > { companion object { fun < Key : Any > by ( maxLastFailedSync : suspend ( key : Key ) -> Long? , setLastFailedSync : suspend ( key : Key , timestamp : Long ) -> Boolean , clear : suspend ( key : Key ) -> Boolean , clearAll : suspend () -> Boolean ): Bookkeeper < Key > } } Example fun provide ( db : NotesDatabase , bookkeeping : BookkeepingDatabase ): Bookkeeper < NotesKey > = Bookkeeper . by ( maxLastFailedSync = { key : NotesKey -> require ( key is NotesKey . Read ) when ( key ) { is NotesKey . Read . ByNoteId -> { bookkeeping . getByNoteId ( key . noteId ) } is NotesKey . Read . ByAuthorId -> { val notes = db . getByAuthorId ( key . authorId ) bookkeeping . maxLastFailedSync ( notes ) } is NotesKey . Read . Paginated -> { val notes = db . getNotes ( key . start , key . size ) bookkeeping . maxLastFailedSync ( notes ) } } }, setLastFailedSync = { key : NotesKey , timestamp : Long -> require ( key !is NotesKey . Clear ) try { when ( key ) { is NotesKey . Read . ByNoteId -> { bookkeeping . upsert ( key . noteId , timestamp ) true } is NotesKey . Read . ByAuthorId -> { val notes = db . getByAuthorId ( key . authorId ) notes . forEach { note : Note -> bookkeeping . upsert ( note . id , timestamp ) } true } is NotesKey . Read . Paginated -> { val notes = db . getNotes ( key . start , key . size ) notes . forEach { note : Note -> bookkeeping . upsert ( note . id , timestamp ) } true } is NotesKey . Write . ById -> { bookkeeping . upsert ( key . noteId , timestamp ) true } is NotesKey . Write . Create { false } } } catch ( _ : Throwable ) { false } }, clear = { key : NotesKey -> require ( key is NotesKey . Clear . ById ) try { bookkeeping . deleteById ( key . noteId ) } catch ( _ : Throwable ) { false } }, clearAll = { require ( key is NotesKey . Clear . All ) try { bookkeeping . delete () } catch ( _ : Throwable ) { false } }, ) private fun BookkeepingDatabase . maxLastFailedSync ( notes : List < Note > ): Long? { var maxLastFailedSync : Long? = null notes . forEach { note : Note -> val lastFailedSync = getByNoteId ( note . id ) if ( maxLastFailedSync == null ) { maxLastFailedSync = lastFailedSync } else if ( lastFailedSync != null ) { maxLastFailedSync = max ( maxLastFailedSync , lastFailedSync ) } } return maxLastFailedSync }","title":"Bookkeeper"},{"location":"mutable-store/building/implementations/bookkeeper/#bookkeeper","text":"interface Bookkeeper < Key : Any > { companion object { fun < Key : Any > by ( maxLastFailedSync : suspend ( key : Key ) -> Long? , setLastFailedSync : suspend ( key : Key , timestamp : Long ) -> Boolean , clear : suspend ( key : Key ) -> Boolean , clearAll : suspend () -> Boolean ): Bookkeeper < Key > } }","title":"Bookkeeper"},{"location":"mutable-store/building/implementations/bookkeeper/#example","text":"fun provide ( db : NotesDatabase , bookkeeping : BookkeepingDatabase ): Bookkeeper < NotesKey > = Bookkeeper . by ( maxLastFailedSync = { key : NotesKey -> require ( key is NotesKey . Read ) when ( key ) { is NotesKey . Read . ByNoteId -> { bookkeeping . getByNoteId ( key . noteId ) } is NotesKey . Read . ByAuthorId -> { val notes = db . getByAuthorId ( key . authorId ) bookkeeping . maxLastFailedSync ( notes ) } is NotesKey . Read . Paginated -> { val notes = db . getNotes ( key . start , key . size ) bookkeeping . maxLastFailedSync ( notes ) } } }, setLastFailedSync = { key : NotesKey , timestamp : Long -> require ( key !is NotesKey . Clear ) try { when ( key ) { is NotesKey . Read . ByNoteId -> { bookkeeping . upsert ( key . noteId , timestamp ) true } is NotesKey . Read . ByAuthorId -> { val notes = db . getByAuthorId ( key . authorId ) notes . forEach { note : Note -> bookkeeping . upsert ( note . id , timestamp ) } true } is NotesKey . Read . Paginated -> { val notes = db . getNotes ( key . start , key . size ) notes . forEach { note : Note -> bookkeeping . upsert ( note . id , timestamp ) } true } is NotesKey . Write . ById -> { bookkeeping . upsert ( key . noteId , timestamp ) true } is NotesKey . Write . Create { false } } } catch ( _ : Throwable ) { false } }, clear = { key : NotesKey -> require ( key is NotesKey . Clear . ById ) try { bookkeeping . deleteById ( key . noteId ) } catch ( _ : Throwable ) { false } }, clearAll = { require ( key is NotesKey . Clear . All ) try { bookkeeping . delete () } catch ( _ : Throwable ) { false } }, ) private fun BookkeepingDatabase . maxLastFailedSync ( notes : List < Note > ): Long? { var maxLastFailedSync : Long? = null notes . forEach { note : Note -> val lastFailedSync = getByNoteId ( note . id ) if ( maxLastFailedSync == null ) { maxLastFailedSync = lastFailedSync } else if ( lastFailedSync != null ) { maxLastFailedSync = max ( maxLastFailedSync , lastFailedSync ) } } return maxLastFailedSync }","title":"Example"},{"location":"mutable-store/building/implementations/converter/","text":"Converter interface Converter < Network : Any , Common : Any , SOT : Any > { class Builder < Network : Any , Common : Any , SOT : Any > { fun build (): Converter < Network , Common , SOT > = RealConverter ( fromNetworkToCommon = fromNetworkToCommon , fromCommonToSOT = fromCommonToSOT , from SOTToCommon = fromSOTToCommon ) } } Example fun provide (): Converter < NetworkNote , CommonNote , Note > = Converter . Builder () . fromNetworkToCommon { network : Network -> CommonNote ( id = network . _id , authorId = network . authorId , title = network . title , content = network . content ) } . fromCommonToSOT { common : Common -> Note ( id = common . id , authorId = common . authorId , title = common . title , content = common . content , ttl = common . ttl ?: ttl () ) } . fromSOTToCommon { sot : SOT -> CommonNote ( id = sot . id , authorId = sot . authorId , title = sot . title , content = sot . content , ttl = sot . ttl ) } . build ()","title":"Converter"},{"location":"mutable-store/building/implementations/converter/#converter","text":"interface Converter < Network : Any , Common : Any , SOT : Any > { class Builder < Network : Any , Common : Any , SOT : Any > { fun build (): Converter < Network , Common , SOT > = RealConverter ( fromNetworkToCommon = fromNetworkToCommon , fromCommonToSOT = fromCommonToSOT , from SOTToCommon = fromSOTToCommon ) } }","title":"Converter"},{"location":"mutable-store/building/implementations/converter/#example","text":"fun provide (): Converter < NetworkNote , CommonNote , Note > = Converter . Builder () . fromNetworkToCommon { network : Network -> CommonNote ( id = network . _id , authorId = network . authorId , title = network . title , content = network . content ) } . fromCommonToSOT { common : Common -> Note ( id = common . id , authorId = common . authorId , title = common . title , content = common . content , ttl = common . ttl ?: ttl () ) } . fromSOTToCommon { sot : SOT -> CommonNote ( id = sot . id , authorId = sot . authorId , title = sot . title , content = sot . content , ttl = sot . ttl ) } . build ()","title":"Example"},{"location":"mutable-store/building/implementations/fetcher/","text":"Fetcher interface Fetcher < Key : Any , Network : Any > { companion object { fun < Key : Any , Network : Any > of ( fetch : suspend ( key : Key ) -> Network ): Fetcher < Key , Network > } } Example fun provide ( api : NotesApi ): Fetcher < NotesKey , NetworkNote > = Fetcher . of { key : NotesKey -> require ( key is NotesKey . Read ) when ( key ) { is NotesKey . Read . ByNoteId -> api . getNoteById ( key . noteId ) is NotesKey . Read . ByAuthorId -> api . getNotesByAuthorId ( key . authorId ) is NotesKey . Read . Paginated -> api . getNotes ( key . start , key . size ) } }","title":"Fetcher"},{"location":"mutable-store/building/implementations/fetcher/#fetcher","text":"interface Fetcher < Key : Any , Network : Any > { companion object { fun < Key : Any , Network : Any > of ( fetch : suspend ( key : Key ) -> Network ): Fetcher < Key , Network > } }","title":"Fetcher"},{"location":"mutable-store/building/implementations/fetcher/#example","text":"fun provide ( api : NotesApi ): Fetcher < NotesKey , NetworkNote > = Fetcher . of { key : NotesKey -> require ( key is NotesKey . Read ) when ( key ) { is NotesKey . Read . ByNoteId -> api . getNoteById ( key . noteId ) is NotesKey . Read . ByAuthorId -> api . getNotesByAuthorId ( key . authorId ) is NotesKey . Read . Paginated -> api . getNotes ( key . start , key . size ) } }","title":"Example"},{"location":"mutable-store/building/implementations/source-of-truth/","text":"Source of Truth interface SourceOfTruth < Key : Any , SOT : Any > { companion object { fun < Key : Any , SOT : Any > of ( reader : ( Key ) -> Flow < SOT?> , writer : suspend ( Key , SOT ) -> Unit , delete : ( suspend ( Key ) -> Unit ) ? = null , deleteAll : ( suspend () -> Unit ) ? = null ): SourceOfTruth < Key , SOT > } } Example fun provide ( db : NotesDatabase ): SourceOfTruth < NotesKey , Note > = SourceOfTruth . of ( reader = { key : NotesKey -> require ( key is NotesKey . Read ) flow { when ( key ) { is NotesKey . Read . ByNoteId -> emit ( db . getNoteById ( key . noteId )) is NotesKey . Read . ByAuthorId -> emit ( db . getNotesByAuthorId ( key . authorId )) is NotesKey . Read . Paginated -> emit ( db . getNotes ( key . start , key . size )) } } }, writer = { key : NotesKey , input : SOT -> require ( key is NotesKey . Write ) when ( key ) { is NotesKey . Write . Create -> db . create ( input ) is NotesKey . Write . ById -> db . update ( key . noteId , input ) } }, delete = { key : NotesKey -> require ( key is NotesKey . Clear . ById ) db . deleteById ( key . noteId ) }, deleteAll = db . delete () )","title":"Source of Truth"},{"location":"mutable-store/building/implementations/source-of-truth/#source-of-truth","text":"interface SourceOfTruth < Key : Any , SOT : Any > { companion object { fun < Key : Any , SOT : Any > of ( reader : ( Key ) -> Flow < SOT?> , writer : suspend ( Key , SOT ) -> Unit , delete : ( suspend ( Key ) -> Unit ) ? = null , deleteAll : ( suspend () -> Unit ) ? = null ): SourceOfTruth < Key , SOT > } }","title":"Source of Truth"},{"location":"mutable-store/building/implementations/source-of-truth/#example","text":"fun provide ( db : NotesDatabase ): SourceOfTruth < NotesKey , Note > = SourceOfTruth . of ( reader = { key : NotesKey -> require ( key is NotesKey . Read ) flow { when ( key ) { is NotesKey . Read . ByNoteId -> emit ( db . getNoteById ( key . noteId )) is NotesKey . Read . ByAuthorId -> emit ( db . getNotesByAuthorId ( key . authorId )) is NotesKey . Read . Paginated -> emit ( db . getNotes ( key . start , key . size )) } } }, writer = { key : NotesKey , input : SOT -> require ( key is NotesKey . Write ) when ( key ) { is NotesKey . Write . Create -> db . create ( input ) is NotesKey . Write . ById -> db . update ( key . noteId , input ) } }, delete = { key : NotesKey -> require ( key is NotesKey . Clear . ById ) db . deleteById ( key . noteId ) }, deleteAll = db . delete () )","title":"Example"},{"location":"mutable-store/building/implementations/updater/","text":"Updater interface Updater < Key : Any , Common : Any , UpdaterResult : Any > { companion object { fun < Key : Any , Common : Any , UpdaterResult : Any > by ( post : suspend ( key : Key , input : Common ) -> UpdaterResult , onCompletion : OnUpdaterCompletion < UpdaterResult >? = null , ): Updater < Key , Common , UpdaterResult > } } Example fun provide ( api : NotesApi ): Updater < NotesKey , CommonNote , NotesUpdaterResult > = Updater . by ( post = { key : NotesKey , input : CommonNote -> require ( key is NotesKey . Write ) when ( key ) { is NotesKey . Write . Create -> api . create ( input ) is NotesKey . Write . ById -> api . update ( key . noteId , input ) } }, onCompletion = OnUpdaterCompletion ( onSuccess = { success : UpdaterResult . Success -> UserLogger . post ( StoreEvents . Update ( success . status )) }, onFailure = { failure : UpdaterResult . Error -> UserLogger . post ( StoreEvents . Update ( failure . status )) } ) )","title":"Updater"},{"location":"mutable-store/building/implementations/updater/#updater","text":"interface Updater < Key : Any , Common : Any , UpdaterResult : Any > { companion object { fun < Key : Any , Common : Any , UpdaterResult : Any > by ( post : suspend ( key : Key , input : Common ) -> UpdaterResult , onCompletion : OnUpdaterCompletion < UpdaterResult >? = null , ): Updater < Key , Common , UpdaterResult > } }","title":"Updater"},{"location":"mutable-store/building/implementations/updater/#example","text":"fun provide ( api : NotesApi ): Updater < NotesKey , CommonNote , NotesUpdaterResult > = Updater . by ( post = { key : NotesKey , input : CommonNote -> require ( key is NotesKey . Write ) when ( key ) { is NotesKey . Write . Create -> api . create ( input ) is NotesKey . Write . ById -> api . update ( key . noteId , input ) } }, onCompletion = OnUpdaterCompletion ( onSuccess = { success : UpdaterResult . Success -> UserLogger . post ( StoreEvents . Update ( success . status )) }, onFailure = { failure : UpdaterResult . Error -> UserLogger . post ( StoreEvents . Update ( failure . status )) } ) )","title":"Example"},{"location":"mutable-store/building/implementations/validator/","text":"Validator interface Validator < Common : Any > { fun isValid ( item : Common ): Boolean } Example class RealValidator < Common : Any > ( private val expiration : Long ) : Validator < Common > { override fun isValid ( item : Common ) = if ( item . ttl == null ) { true } else { item . ttl < expiration } }","title":"Validator"},{"location":"mutable-store/building/implementations/validator/#validator","text":"interface Validator < Common : Any > { fun isValid ( item : Common ): Boolean }","title":"Validator"},{"location":"mutable-store/building/implementations/validator/#example","text":"class RealValidator < Common : Any > ( private val expiration : Long ) : Validator < Common > { override fun isValid ( item : Common ) = if ( item . ttl == null ) { true } else { item . ttl < expiration } }","title":"Example"},{"location":"store/store/","text":"Store Fully Configured Store Let's start by looking at what a fully configured Store looks like. We will then walk through simpler examples showing each piece: StoreBuilder . from ( fetcher = Fetcher . of { api . fetchSubreddit ( it , \"10\" ). data . children . map ( :: toPosts ) }, sourceOfTruth = SourceOfTruth . of ( reader = db . postDao () :: loadPosts , writer = db . postDao () :: insertPosts , delete = db . postDao () :: clearFeed , deleteAll = db . postDao () :: clearAllFeeds ) ). build () With the above setup you have: In-memory caching for rotation Disk caching for when users are offline Throttling of API calls when parallel requests are made for the same resource Rich API to ask for data whether you want cached, new or a stream of future data updates. And now for the details: Creating a Store You create a Store using a builder. The only requirement is to include a Fetcher which is just a typealias to a function that returns a Flow<FetcherResult<ReturnType>> . val store = StoreBuilder . from ( Fetcher . ofFlow { articleId -> api . getArticle ( articleId ) }) // api returns Flow<Article> . build () Store uses generic keys as identifiers for data. A key can be any value object that properly implements toString() , equals() and hashCode() . When your Fetcher function is called, it will be passed a particular Key value. Similarly, the key will be used as a primary identifier within caches (Make sure to have a proper hashCode() !!). Note: We highly recommend using built-in types that implement equals and hashcode or Kotlin data classes for complex keys. Public Interface - Stream The primary function provided by a Store instance is the stream function which has the following signature: fun stream ( request : StoreRequest < Key > ): Flow < StoreResponse < Output >> Each stream call receives a StoreRequest object, which defines which key to fetch and which data sources to utilize. The response is a Flow of StoreResponse . StoreResponse is a Kotlin sealed class that can be either a Loading , Data or Error instance. Each StoreResponse includes an origin field which specifies where the event is coming from. The Loading class only has an origin field. This can provide you information like \"network is fetching data\", which can be a good signal to activate the loading spinner in your UI. The Data class has a value field which includes an instance of the type returned by Store . The Error class includes an error field that contains the exception thrown by the given origin . When an error happens, Store does not throw an exception, instead, it wraps it in a StoreResponse.Error type which allows Flow to continue so that it can still receive updates that might be triggered by either changes in your data source or subsequent fetch operations. viewModelScope . launch { store . stream ( StoreRequest . cached ( key = key , refresh = true )). collect { response -> when ( response ) { is StoreResponse . Loading -> showLoadingSpinner () is StoreResponse . Data -> { if ( response . origin == ResponseOrigin . Fetcher ) hideLoadingSpinner () updateUI ( response . value ) } is StoreResponse . Error -> { if ( response . origin == ResponseOrigin . Fetcher ) hideLoadingSpinner () showError ( response . error ) } } } } For convenience, there are Store.get(key) and Store.fresh(key) extension functions. suspend fun Store.get(key: Key): Value : This method returns a single value for the given key. If available, it will be returned from the in memory cache or the sourceOfTruth. An error will be thrown if no value is available in either the cache or sourceOfTruth , and the fetcher fails to load the data from the network. suspend fun Store.fresh(key: Key): Value : This method returns a single value for the given key that is obtained by querying the fetcher. An error will be thrown if the fetcher fails to load the data from the network, regardless of whether any value is available in the cache or sourceOfTruth . lifecycleScope . launchWhenStarted { val article = store . get ( key ) updateUI ( article ) } The first time you call to suspend store.get(key) , the response will be stored in an in-memory cache and in the sourceOfTruth, if provided. All subsequent calls to store.get(key) with the same Key will retrieve the cached version of the data, minimizing unnecessary data calls. This prevents your app from fetching fresh data over the network (or from another external data source) in situations when doing so would unnecessarily waste bandwidth and battery. A great use case is any time your views are recreated after a rotation, they will be able to request the cached data from your Store. Having this data available can help you avoid the need to retain this in the view layer. By default, 100 items will be cached in memory for 24 hours. You may pass in your own memory policy to override the default policy . Skipping Memory/Disk Alternatively, you can call store.fresh(key) to get a suspended result that skips the memory ( and optional disk cache). A good use case is overnight background updates use fresh() to make sure that calls to store.get() will not have to hit the network during normal usage. Another good use case for fresh() is when a user wants to pull to refresh. Calls to both fresh() and get() emit one value or throw an error. Stream For real-time updates, you may also call store.stream() which returns a Flow<T> that emits each time a new item is returned from your store. You can think of stream as a way to create reactive streams that update when you db or memory cache updates example calls: lifecycleScope . launchWhenStarted { store . stream ( StoreRequest . cached ( 3 , refresh = false ) ) //will get cached value followed by any fresh values, refresh will also trigger network call if set to `true` even if the data is available in cache or disk. . collect {} store . stream ( StoreRequest . fresh ( 3 )) //skip cache, go directly to fetcher . collect {} } Inflight Debouncer To prevent duplicate requests for the same data, Store offers an inflight debouncer. If the same request is made as a previous identical request that has not completed, the same response will be returned. This is useful for situations when your app needs to make many async calls for the same data at startup or when users are obsessively pulling to refresh. As an example, The New York Times news app asynchronously calls ConfigStore.get() from 12 different places on startup. The first call blocks while all others wait for the data to arrive. We have seen a dramatic decrease in the app's data usage after implementing this inflight logic. Disk as Cache Stores can enable disk caching by passing a SourceOfTruth into the builder. Whenever a new network request is made, the Store will first write to the disk cache and then read from the disk cache. Disk as Single Source of Truth Providing sourceOfTruth whose reader function can return a Flow<Value?> allows you to make Store treat your disk as source of truth. Any changes made on disk, even if it is not made by Store, will update the active Store streams. This feature, combined with persistence libraries that provide observable queries ( Jetpack Room , SQLDelight or Realm ) allows you to create offline first applications that can be used without an active network connection while still providing a great user experience. StoreBuilder . from ( fetcher = Fetcher . of { api . fetchSubreddit ( it , \"10\" ). data . children . map ( :: toPosts ) }, sourceOfTruth = SourceOfTruth . of ( reader = db . postDao () :: loadPosts , writer = db . postDao () :: insertPosts , delete = db . postDao () :: clearFeed , deleteAll = db . postDao () :: clearAllFeeds ) ). build () Stores don\u2019t care how you\u2019re storing or retrieving your data from disk. As a result, you can use Stores with object storage or any database (Realm, SQLite, CouchDB, Firebase etc). Technically, there is nothing stopping you from implementing an in-memory cache for the \"sourceOfTruth\" implementation and instead have two levels of in-memory caching--one with inflated and one with deflated models, allowing for sharing of the \u201csourceOfTruth\u201d cache data between stores. If using SQLite we recommend working with Room which returns a Flow from a query The above builder is how we recommend working with data on Android. With the above setup you have: Memory caching with TTL & Size policies Disk caching with simple integration with Room In-flight request management Ability to get cached data or bust through your caches ( get() vs. fresh() ) Ability to listen for any new emissions from network (stream) Structured Concurrency through APIs build on Coroutines and Kotlin Flow Configuring in-memory Cache You can configure in-memory cache with the MemoryPolicy : StoreBuilder . from ( fetcher = Fetcher . of { api . fetchSubreddit ( it , \"10\" ). data . children . map ( :: toPosts ) }, sourceOfTruth = SourceOfTruth . of ( reader = db . postDao () :: loadPosts , writer = db . postDao () :: insertPosts , delete = db . postDao () :: clearFeed , deleteAll = db . postDao () :: clearAllFeeds ) ). cachePolicy ( MemoryPolicy . builder < Any , Any > () . setMaxSize ( 10 ) . setExpireAfterAccess ( 10. minutes ) // or setExpireAfterWrite(10.minutes) . build () ). build () setMaxSize(maxSize: Long) sets the maximum number of entries to be kept in the cache before starting to evict the least recently used items. setExpireAfterAccess(expireAfterAccess: Duration) sets the maximum time an entry can live in the cache since the last access, where \"access\" means reading the cache, adding a new cache entry, and replacing an existing entry with a new one. This duration is also known as time-to-idle (TTI) . setExpireAfterWrite(expireAfterWrite: Duration) sets the maximum time an entry can live in the cache since the last write, where \"write\" means adding a new cache entry and replacing an existing entry with a new one. This duration is also known as time-to-live (TTL) . Note that setExpireAfterAccess and setExpireAfterWrite cannot both be set at the same time. Clearing store entries You can delete a specific entry by key from a store, or clear all entries in a store. Store with no sourceOfTruth val store = StoreBuilder . from ( fetcher = Fetcher . of { key : String -> api . fetchData ( key ) }). build () The following will clear the entry associated with the key from the in-memory cache: store . clear ( \"10\" ) The following will clear all entries from the in-memory cache: store . clearAll () Store with sourceOfTruth When store has a sourceOfTruth, you'll need to provide the delete and deleteAll functions for clear(key) and clearAll() to work: StoreBuilder . from ( fetcher = Fetcher . of { api . fetchData ( key ) }, sourceOfTruth = SourceOfTruth . of ( reader = dao :: loadData , writer = dao :: writeData , delete = dao :: clearDataByKey , deleteAll = dao :: clearAllData ) ). build () The following will clear the entry associated with the key from both the in-memory cache and the sourceOfTruth: store . clear ( \"myKey\" ) The following will clear all entries from both the in-memory cache and the sourceOfTruth: store . clearAll ()","title":"Store"},{"location":"store/store/#store","text":"","title":"Store"},{"location":"store/store/#fully-configured-store","text":"Let's start by looking at what a fully configured Store looks like. We will then walk through simpler examples showing each piece: StoreBuilder . from ( fetcher = Fetcher . of { api . fetchSubreddit ( it , \"10\" ). data . children . map ( :: toPosts ) }, sourceOfTruth = SourceOfTruth . of ( reader = db . postDao () :: loadPosts , writer = db . postDao () :: insertPosts , delete = db . postDao () :: clearFeed , deleteAll = db . postDao () :: clearAllFeeds ) ). build () With the above setup you have: In-memory caching for rotation Disk caching for when users are offline Throttling of API calls when parallel requests are made for the same resource Rich API to ask for data whether you want cached, new or a stream of future data updates. And now for the details:","title":"Fully Configured Store"},{"location":"store/store/#creating-a-store","text":"You create a Store using a builder. The only requirement is to include a Fetcher which is just a typealias to a function that returns a Flow<FetcherResult<ReturnType>> . val store = StoreBuilder . from ( Fetcher . ofFlow { articleId -> api . getArticle ( articleId ) }) // api returns Flow<Article> . build () Store uses generic keys as identifiers for data. A key can be any value object that properly implements toString() , equals() and hashCode() . When your Fetcher function is called, it will be passed a particular Key value. Similarly, the key will be used as a primary identifier within caches (Make sure to have a proper hashCode() !!). Note: We highly recommend using built-in types that implement equals and hashcode or Kotlin data classes for complex keys.","title":"Creating a Store"},{"location":"store/store/#public-interface-stream","text":"The primary function provided by a Store instance is the stream function which has the following signature: fun stream ( request : StoreRequest < Key > ): Flow < StoreResponse < Output >> Each stream call receives a StoreRequest object, which defines which key to fetch and which data sources to utilize. The response is a Flow of StoreResponse . StoreResponse is a Kotlin sealed class that can be either a Loading , Data or Error instance. Each StoreResponse includes an origin field which specifies where the event is coming from. The Loading class only has an origin field. This can provide you information like \"network is fetching data\", which can be a good signal to activate the loading spinner in your UI. The Data class has a value field which includes an instance of the type returned by Store . The Error class includes an error field that contains the exception thrown by the given origin . When an error happens, Store does not throw an exception, instead, it wraps it in a StoreResponse.Error type which allows Flow to continue so that it can still receive updates that might be triggered by either changes in your data source or subsequent fetch operations. viewModelScope . launch { store . stream ( StoreRequest . cached ( key = key , refresh = true )). collect { response -> when ( response ) { is StoreResponse . Loading -> showLoadingSpinner () is StoreResponse . Data -> { if ( response . origin == ResponseOrigin . Fetcher ) hideLoadingSpinner () updateUI ( response . value ) } is StoreResponse . Error -> { if ( response . origin == ResponseOrigin . Fetcher ) hideLoadingSpinner () showError ( response . error ) } } } } For convenience, there are Store.get(key) and Store.fresh(key) extension functions. suspend fun Store.get(key: Key): Value : This method returns a single value for the given key. If available, it will be returned from the in memory cache or the sourceOfTruth. An error will be thrown if no value is available in either the cache or sourceOfTruth , and the fetcher fails to load the data from the network. suspend fun Store.fresh(key: Key): Value : This method returns a single value for the given key that is obtained by querying the fetcher. An error will be thrown if the fetcher fails to load the data from the network, regardless of whether any value is available in the cache or sourceOfTruth . lifecycleScope . launchWhenStarted { val article = store . get ( key ) updateUI ( article ) } The first time you call to suspend store.get(key) , the response will be stored in an in-memory cache and in the sourceOfTruth, if provided. All subsequent calls to store.get(key) with the same Key will retrieve the cached version of the data, minimizing unnecessary data calls. This prevents your app from fetching fresh data over the network (or from another external data source) in situations when doing so would unnecessarily waste bandwidth and battery. A great use case is any time your views are recreated after a rotation, they will be able to request the cached data from your Store. Having this data available can help you avoid the need to retain this in the view layer. By default, 100 items will be cached in memory for 24 hours. You may pass in your own memory policy to override the default policy .","title":"Public Interface - Stream"},{"location":"store/store/#skipping-memorydisk","text":"Alternatively, you can call store.fresh(key) to get a suspended result that skips the memory ( and optional disk cache). A good use case is overnight background updates use fresh() to make sure that calls to store.get() will not have to hit the network during normal usage. Another good use case for fresh() is when a user wants to pull to refresh. Calls to both fresh() and get() emit one value or throw an error.","title":"Skipping Memory/Disk"},{"location":"store/store/#stream","text":"For real-time updates, you may also call store.stream() which returns a Flow<T> that emits each time a new item is returned from your store. You can think of stream as a way to create reactive streams that update when you db or memory cache updates example calls: lifecycleScope . launchWhenStarted { store . stream ( StoreRequest . cached ( 3 , refresh = false ) ) //will get cached value followed by any fresh values, refresh will also trigger network call if set to `true` even if the data is available in cache or disk. . collect {} store . stream ( StoreRequest . fresh ( 3 )) //skip cache, go directly to fetcher . collect {} }","title":"Stream"},{"location":"store/store/#inflight-debouncer","text":"To prevent duplicate requests for the same data, Store offers an inflight debouncer. If the same request is made as a previous identical request that has not completed, the same response will be returned. This is useful for situations when your app needs to make many async calls for the same data at startup or when users are obsessively pulling to refresh. As an example, The New York Times news app asynchronously calls ConfigStore.get() from 12 different places on startup. The first call blocks while all others wait for the data to arrive. We have seen a dramatic decrease in the app's data usage after implementing this inflight logic.","title":"Inflight Debouncer"},{"location":"store/store/#disk-as-cache","text":"Stores can enable disk caching by passing a SourceOfTruth into the builder. Whenever a new network request is made, the Store will first write to the disk cache and then read from the disk cache.","title":"Disk as Cache"},{"location":"store/store/#disk-as-single-source-of-truth","text":"Providing sourceOfTruth whose reader function can return a Flow<Value?> allows you to make Store treat your disk as source of truth. Any changes made on disk, even if it is not made by Store, will update the active Store streams. This feature, combined with persistence libraries that provide observable queries ( Jetpack Room , SQLDelight or Realm ) allows you to create offline first applications that can be used without an active network connection while still providing a great user experience. StoreBuilder . from ( fetcher = Fetcher . of { api . fetchSubreddit ( it , \"10\" ). data . children . map ( :: toPosts ) }, sourceOfTruth = SourceOfTruth . of ( reader = db . postDao () :: loadPosts , writer = db . postDao () :: insertPosts , delete = db . postDao () :: clearFeed , deleteAll = db . postDao () :: clearAllFeeds ) ). build () Stores don\u2019t care how you\u2019re storing or retrieving your data from disk. As a result, you can use Stores with object storage or any database (Realm, SQLite, CouchDB, Firebase etc). Technically, there is nothing stopping you from implementing an in-memory cache for the \"sourceOfTruth\" implementation and instead have two levels of in-memory caching--one with inflated and one with deflated models, allowing for sharing of the \u201csourceOfTruth\u201d cache data between stores. If using SQLite we recommend working with Room which returns a Flow from a query The above builder is how we recommend working with data on Android. With the above setup you have: Memory caching with TTL & Size policies Disk caching with simple integration with Room In-flight request management Ability to get cached data or bust through your caches ( get() vs. fresh() ) Ability to listen for any new emissions from network (stream) Structured Concurrency through APIs build on Coroutines and Kotlin Flow","title":"Disk as Single Source of Truth"},{"location":"store/store/#configuring-in-memory-cache","text":"You can configure in-memory cache with the MemoryPolicy : StoreBuilder . from ( fetcher = Fetcher . of { api . fetchSubreddit ( it , \"10\" ). data . children . map ( :: toPosts ) }, sourceOfTruth = SourceOfTruth . of ( reader = db . postDao () :: loadPosts , writer = db . postDao () :: insertPosts , delete = db . postDao () :: clearFeed , deleteAll = db . postDao () :: clearAllFeeds ) ). cachePolicy ( MemoryPolicy . builder < Any , Any > () . setMaxSize ( 10 ) . setExpireAfterAccess ( 10. minutes ) // or setExpireAfterWrite(10.minutes) . build () ). build () setMaxSize(maxSize: Long) sets the maximum number of entries to be kept in the cache before starting to evict the least recently used items. setExpireAfterAccess(expireAfterAccess: Duration) sets the maximum time an entry can live in the cache since the last access, where \"access\" means reading the cache, adding a new cache entry, and replacing an existing entry with a new one. This duration is also known as time-to-idle (TTI) . setExpireAfterWrite(expireAfterWrite: Duration) sets the maximum time an entry can live in the cache since the last write, where \"write\" means adding a new cache entry and replacing an existing entry with a new one. This duration is also known as time-to-live (TTL) . Note that setExpireAfterAccess and setExpireAfterWrite cannot both be set at the same time.","title":"Configuring in-memory Cache"},{"location":"store/store/#clearing-store-entries","text":"You can delete a specific entry by key from a store, or clear all entries in a store.","title":"Clearing store entries"},{"location":"store/store/#store-with-no-sourceoftruth","text":"val store = StoreBuilder . from ( fetcher = Fetcher . of { key : String -> api . fetchData ( key ) }). build () The following will clear the entry associated with the key from the in-memory cache: store . clear ( \"10\" ) The following will clear all entries from the in-memory cache: store . clearAll ()","title":"Store with no sourceOfTruth"},{"location":"store/store/#store-with-sourceoftruth","text":"When store has a sourceOfTruth, you'll need to provide the delete and deleteAll functions for clear(key) and clearAll() to work: StoreBuilder . from ( fetcher = Fetcher . of { api . fetchData ( key ) }, sourceOfTruth = SourceOfTruth . of ( reader = dao :: loadData , writer = dao :: writeData , delete = dao :: clearDataByKey , deleteAll = dao :: clearAllData ) ). build () The following will clear the entry associated with the key from both the in-memory cache and the sourceOfTruth: store . clear ( \"myKey\" ) The following will clear all entries from both the in-memory cache and the sourceOfTruth: store . clearAll ()","title":"Store with sourceOfTruth"}]}